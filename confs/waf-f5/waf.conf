cat waf.conf 
input
{
        tcp
        {
                port => 5002
		tags => ["waf"]
        }
}
filter
{
	if "waf" in [tags]
	{
  		# First, parse the syslog wrapper
		grok 
		{
			match => 
			{ 
				"message" => [
						"^<%{POSINT:priority}>%{SYSLOGTIMESTAMP:syslog_timestamp} %{IPORHOST:syslog_host} ASM:%{GREEDYDATA:csv_data}$",
					        "^(?<kv_data>.+)$"
					     ]
			}
		}
	  
		# Only process if we successfully extracted CSV data
		if [csv_data] 
		{
      			mutate { add_tag => ["csv_parser"] }

			# Parse the CSV portion
			csv 
			{
				source => "csv_data"
				separator => ","
				columns => 
				[
					"attack_type", "blocking_exception_reason", "captcha_result", "client_type", "compression_method", "conviction_traps", "credential_stuffing_lookup_result", "date_time", "dest_ip", "dest_port", "device_id", "enforced_by", "enforcement_action", "epoch_time", "fragment", "geo_location", "http_class_name", "ip_address_intelligence", "ip_client", "ip_with_route_domain", "is_truncated", "likely_false_positive_sig_ids", "login_result", "management_ip_address", "management_ip_address_2", "method", "microservice", "mobile_application_name", "mobile_application_version", "operation_id", "password_hash_prefix", "policy_apply_date", "policy_name", "protocol", "protocol_info", "query_string", "request", "request_status", "response", "response_code", "route_domain", "session_id", "severity", "sig_cves", "sig_ids", "sig_names", "sig_set_names", "slot_number", "src_port", "staged_sig_cves", "staged_sig_ids", "staged_sig_names", "staged_sig_set_names", "staged_threat_campaign_names", "sub_violations", "support_id", "tap_event_id", "tap_requested_action", "tap_sent_token", "tap_transaction_id", "tap_vid", "threat_campaign_names", "unit_hostname", "uri", "username", "violation_details", "violation_rating", "violations", "virus_name", "vs_name", "websocket_direction", "websocket_message_type", "x_forwarded_for_header_value"
				]
			skip_empty_columns => true
			}
	    
			# Clean up - remove the original fields we don't need
			mutate 
			{
				remove_field => ["message", "csv_data"]
			}
	    
			# Optional: Convert syslog timestamp to proper timestamp
			date 
			{
				match => [ "syslog_timestamp", "MMM  d HH:mm:ss", "MMM dd HH:mm:ss" ]
				target => "syslog_parsed_time"
			}
			geoip
			{
				source => "ip_client"
				target => "ip_client_geoip"
			}
			geoip
			{
				default_database_type => 'ASN'
				database => '/opt/maxmind/output/GeoLite2-ASN.mmdb'
				cache_size => 5000
				source => 'ip_client'
				target => 'ip_client_asn'
			}
			translate
			{
				source => "[ip_client]"
				target => "[is_tor]"
				dictionary_path => "/etc/logstash/dictionaries/tor_nodes/torexil.yml"
			}
			ruby 
			{
				code => '
				req = event.get("request")
				if req
				# Case-insensitive match for "Host:"
					if match = req.match(/Host:\s*(.*?)\\r\\n/i)
						event.set("dest_host", match[1].downcase)
					end
				end
				'
			}
		}
		else if [kv_data]
		{
			kv 
			{
				source => "kv_data"
			    	field_split => ","
			    	value_split => "="
			    	include_brackets => false
			    	trim_key => "\""
			    	trim_value => "\""
			    	remove_char_key => "\""
			    	remove_char_value => "\""
			}
			mutate 
			{
				gsub => ["[http_request]", "\\\\r\\\\n", "\n"]
			}
			mutate 
			{
				convert => 
				{
			      		"[client_port]" => "integer"
			      		"[dest_port]" => "integer"
			    	}
			}
			date 
			{
				match => ["[timestamp]", "MMM dd YYYY HH:mm:ss"]
				timezone => "UTC"
				target => "syslog_parsed_time"
			}
	   	        mutate 
			{
				add_tag => ["kv_parser"]
			}
                        # Clean up - remove the original fields we don't need
                        mutate 
                        {
                                remove_field => ["message", "kv_data"]
                        }
			geoip
			{
				source => "client_ip"
				target => "client_ip_geoip"
			}
			geoip
			{
				default_database_type => 'ASN'
				database => '/opt/maxmind/output/GeoLite2-ASN.mmdb'
				cache_size => 5000
				source => 'client_ip'
				target => 'client_ip_asn'
			}
			translate
			{
				source => "[client_ip]"
				target => "[is_tor]"
				dictionary_path => "/etc/logstash/dictionaries/tor_nodes/torexil.yml"
			}
		}
	}
}
output
{
        if "waf" in [tags]
        {
                elasticsearch
                {
                        hosts => ["https://localhost:9200"]
                        index => "waf-%{+YYYY.MM}"
                        user  => "elastic"
                        password => "yourpassword"
                        ssl_verification_mode => none
                }
  		#file 
		#{
    		#	path => "/var/log/logstash/waf.log"
    		#	codec => line { format => "%{message}" }
  		#}
        }
}






